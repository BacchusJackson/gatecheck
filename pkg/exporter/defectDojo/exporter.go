package defectDojo

import (
	"fmt"
	"github.com/gatecheckdev/gatecheck/pkg/exporter"
	"github.com/gatecheckdev/gatecheck/pkg/exporter/defectDojo/models"
	"io"
	"log"
	"math"
	"time"
)

const Timezone string = "America/New_York"

type Config struct {
	ProductTypeName    string
	ProductName        string
	EngagementName     string
	EngagementDuration time.Duration
	CommitHash         string
	BranchTag          string
	SourceURL          string
}

type Exporter struct {
	service       Service
	config        Config
	RetryDuration time.Duration
}

func NewExporter(c Config) *Exporter {
	return &Exporter{config: c, RetryDuration: time.Second}
}

func (e Exporter) WithService(s Service) *Exporter {
	e.service = s
	return &e
}

func (e Exporter) Export(r io.Reader, scanType exporter.ScanType) error {
	engagement, err := e.GenerateEngagement()
	if err != nil {
		return err
	}

	_, err = e.service.PostScan(r, engagement.Id, scanType)

	return err
}

// ExportWithRetry calls Export in a backoff retry loop. Each loop has an exponential backoff
func (e Exporter) ExportWithRetry(r io.Reader, scanType exporter.ScanType, maxAttempts uint) error {
	var err error

	for i := 0; i < int(maxAttempts); i++ {
		err = e.Export(r, scanType)
		if err == nil {
			return nil
		}
		// Sleep for 2 ^ backoff, seconds
		sleepFor := time.Duration(int64(math.Pow(2, float64(i)))) * e.RetryDuration
		log.Printf("Export Attempt %d / %d, will Retrying after %s. Error: %v\n", i+1, maxAttempts,
			sleepFor.String(), err)
		time.Sleep(sleepFor)
	}

	return err
}

func (e Exporter) getProductType(name string) (*models.ProductType, error) {
	productTypes, err := e.service.GetProductTypes()
	if err != nil {
		return nil, err
	}
	// Check for a product type with the matching name
	for _, productType := range productTypes {
		if productType.Name == name {
			return &productType, nil
		}
	}
	// Create a new product type if it doesn't already exist
	return e.service.PostProductType(models.ProductType{Name: name, Description: autoGenDescription(Timezone)})
}

func (e Exporter) getProduct(productTypeID int, name string) (*models.Product, error) {
	products, err := e.service.GetProducts()
	if err != nil {
		return nil, err
	}
	// check for product with a matching name
	for _, product := range products {
		if product.ProdType == productTypeID && product.Name == name {
			return &product, nil
		}
	}
	// Create if it doesn't already exist
	return e.service.PostProduct(models.Product{
		Name:        name,
		Description: autoGenDescription(Timezone),
		ProdType:    productTypeID})
}

func (e Exporter) getEngagement(productID int, name string) (*models.Engagement, error) {
	engagements, err := e.service.GetEngagementsByProduct(productID)
	if err != nil {
		return nil, err
	}
	// check for existing engagement
	for _, engagement := range engagements {
		if engagement.Product == productID && engagement.Name == name {
			return &engagement, nil
		}
	}
	loc, _ := time.LoadLocation("EST")
	// Create if it doesn't exist
	return e.service.PostEngagement(models.Engagement{
		Name:                    name,
		Description:             autoGenDescription(Timezone),
		TargetStart:             time.Now().In(loc).Format("2006-01-02"),
		TargetEnd:               time.Now().In(loc).Add(e.config.EngagementDuration).Format("2006-01-02"),
		Product:                 productID,
		Active:                  true,
		Status:                  "In Progress",
		EngagementType:          "CI/CD",
		CommitHash:              e.config.CommitHash,
		BranchTag:               e.config.BranchTag,
		SourceCodeManagementUri: e.config.SourceURL,
	})
}

func autoGenDescription(timezone string) string {
	loc, err := time.LoadLocation(timezone)
	if err != nil {
		timeStamp := time.Now().UTC().Format("02 January 2006, 15:04 UTC")
		return fmt.Sprintf("Auto-generated by Gate Check %s", timeStamp)
	}
	timeStamp := time.Now().In(loc).Format("02 January 2006, 15:04 EST")
	return fmt.Sprintf("Auto-generated by Gate Check %s", timeStamp)
}

func (e Exporter) GenerateEngagement() (*models.Engagement, error) {
	productType, err := e.getProductType(e.config.ProductTypeName)
	if err != nil {
		return nil, err
	}

	product, err := e.getProduct(productType.Id, e.config.ProductName)
	if err != nil {
		return nil, err
	}

	engagement, err := e.getEngagement(product.Id, e.config.EngagementName)
	if err != nil {
		return nil, err
	}

	return engagement, nil
}

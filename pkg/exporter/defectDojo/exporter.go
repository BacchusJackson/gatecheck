package defectDojo

import (
	"fmt"
	"github.com/gatecheckdev/gatecheck/pkg/exporter/defectDojo/models"
	"io"
	"time"
)

type Config struct {
	ProductTypeName    string
	ProductName        string
	EngagementName     string
	EngagementDuration time.Duration
	CommitHash         string
	BranchTag          string
	SourceURL          string
}

type Exporter struct {
	service Service
	config  Config
}

func NewExporter(c Config) *Exporter {
	return &Exporter{config: c}
}

func (e Exporter) WithService(s Service) *Exporter {
	e.service = s
	return &e
}

func (e Exporter) ExportGrype(r io.Reader) error {
	productType, err := e.getProductType(e.config.ProductTypeName)
	if err != nil {
		return err
	}

	product, err := e.getProduct(productType.Id, e.config.ProductName)
	if err != nil {
		return err
	}

	engagement, err := e.getEngagement(product.Id, e.config.EngagementName)
	if err != nil {
		return err
	}

	_, err = e.service.PostScan(r, engagement.Id, Grype)

	return err
}

func (e Exporter) getProductType(name string) (*models.ProductType, error) {
	productTypes, err := e.service.GetProductTypes()
	if err != nil {
		return nil, err
	}
	// Check for a product type with the matching name
	for _, productType := range productTypes {
		if productType.Name == name {
			return &productType, nil
		}
	}
	// Create a new product type if it doesn't already exist
	return e.service.PostProductType(models.ProductType{Name: name, Description: autoGenDescription()})
}

func (e Exporter) getProduct(productTypeID int, name string) (*models.Product, error) {
	products, err := e.service.GetProducts()
	if err != nil {
		return nil, err
	}
	// check for product with a matching name
	for _, product := range products {
		if product.ProdType == productTypeID && product.Name == name {
			return &product, nil
		}
	}
	// Create if it doesn't already exist
	return e.service.PostProduct(models.Product{Name: name, Description: autoGenDescription(), ProdType: productTypeID})
}

func (e Exporter) getEngagement(productID int, name string) (*models.Engagement, error) {
	engagements, err := e.service.GetEngagementsByProduct(productID)
	if err != nil {
		return nil, err
	}
	// check for existing engagement
	for _, engagement := range engagements {
		if engagement.Product == productID && engagement.Name == name {
			return &engagement, nil
		}
	}
	loc, _ := time.LoadLocation("EST")
	// Create if it doesn't exist
	return e.service.PostEngagement(models.Engagement{
		Name:                    name,
		Description:             autoGenDescription(),
		TargetStart:             time.Now().In(loc).Format("2006-01-02"),
		TargetEnd:               time.Now().In(loc).Add(e.config.EngagementDuration).Format("2006-01-02"),
		Product:                 productID,
		Active:                  true,
		Status:                  "In Progress",
		EngagementType:          "CI/CD",
		CommitHash:              e.config.CommitHash,
		BranchTag:               e.config.BranchTag,
		SourceCodeManagementUri: e.config.SourceURL,
	})
}

func autoGenDescription() string {
	loc, _ := time.LoadLocation("America/New_York")
	timeStamp := time.Now().In(loc).Format("02 January 2006, 15:04 EST")
	return fmt.Sprintf("Auto-generated by Gate Check %s", timeStamp)
}
